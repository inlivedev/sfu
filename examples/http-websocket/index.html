<!DOCTYPE html>
<head>
    <title>HTTP WebSocket Example</title>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            display: flex;
            align-items: stretch;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            justify-content: space-between;
        }
        h1 {
            margin: 0;
            padding: 0.5em 0;
        }

        header{
           text-align: center;
        }

        main {
            display: grid;
            justify-content: center;
            align-items: center;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            grid-template-rows: repeat(auto-fit, minmax(240px, 1fr));
            grid-gap: 0.5rem;
        }

        aside {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1em;
        }
        video {
            background-color: black;
            align-self: center;
            justify-self: center;
            width: auto;
            min-width: 320px;
            min-height: 0;
            height: auto;
        }
    </style>
</head>
<body>
    <header>
        <h1>HTTP WebSocket Example</h1>
        <p>Open the console to see the output.</p>
    </header>
    <main>
        <video id="localVideo"></video>
    </main>
    <aside><button onclick="start()" disabled>Start</button></aside>
    <script>
          const peerConnection = new RTCPeerConnection({
                    iceServers: [
                        {
                            urls: "stun:stun.l.google.com:19302"
                        },
                    ]
                });
        const ws = new WebSocket("ws://localhost:8000/ws");
        ws.onopen = function() {
            console.log("websocket open");
            document.querySelector("button").disabled = false;
        };
        ws.onmessage = async function(e) {

            const msg = JSON.parse(e.data);
            try {
                if (msg.type == 'offer') {
                    await peerConnection.setRemoteDescription(msg.data);
                    var answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    ws.send(JSON.stringify({type:'answer',data:answer.sdp}));
                } else if (msg.type == 'answer') {
                    await peerConnection.setRemoteDescription(msg.data);
                } else if (msg.type == 'candidate') {
                    await peerConnection.addIceCandidate(msg.data);
                } else if (msg.type == 'allow_renegotiation') {
                    // use this event to retry renegotation when doing renegotation was not allowed
                } else if (msg.type == 'tracks_added') {
                    const trackType = {}
                    const tracksAdded = msg.data
                    Object.keys(tracksAdded).forEach(uid => {
                        // we suppose to check tracksAdded[key].id and compare it with current track id from  navigator.mediaDevices.getUserMedia() to know the source is media 
                        trackType[uid] = "media"
                    });

                    ws.send(JSON.stringify({type:'tracks_added',data:trackType}));
                } else if (msg.type == 'tracks_available') {
                    const subTracks = []
                    const availableTracks = msg.data
                    Object.keys(availaleTracks).forEach(uid => {
                        // we suppose to check tracksAdded[key].id and compare it with current track id from  navigator.mediaDevices.getUserMedia() to know the source is media 
                        // ClientID string `json:"client_id"`
                        // StreamID string `json:"stream_id"`
                        // TrackID  string `json:"track_id"`
                        // RID      string `json:"rid"`
                        const track = availableTracks[uid]
                        subTracks.push({
                            client_id: track.client_id,
                            track_id: track.id,
                        })
                    });

                    ws.send(JSON.stringify({type:'tracks_available',data:trackType}));
                }
            } catch (error) {
                console.log(error);
            }
        };
        ws.onclose = function() {
            console.log("websocket close");
        };

        async function start() {
            document.querySelector("button").disabled = true;
            var localVideo = document.getElementById("localVideo");
            const video = {
                '1080p': {width: 1920, height: 1080},
                '720p': {width: 1280, height: 720},
                '360p': {width: 640, height: 360},
                };
            var constraints = {
                audio: true,
                video: video
                // video: true
            };
            
            stream = await navigator.mediaDevices.getUserMedia(constraints)
            localVideo.srcObject = stream;
            localVideo.play();

            peerConnection.ontrack = function(e) {
                if(e.track.kind != "video") {
                    return
                }

                const streamid = e.streams[0].id;
                console.log("ontrack");
                let remoteVideo = document.querySelector("video-"+streamid);
                if (!remoteVideo) {
                    remoteVideo = document.createElement("video");
                    remoteVideo.id = "video-"+streamid;
                    remoteVideo.autoplay = true;
                    document.querySelector('main').appendChild(remoteVideo);
                }

                remoteVideo.srcObject = e.streams[0];

                e.streams[0].onremovetrack = function() {
                    console.log("onremovetrack");
                    remoteVideo.srcObject = null;
                    remoteVideo.remove();
                };
            };

            // peerConnection.addTrack(stream.getAudioTracks()[0], stream);
            // peerConnection.addTrack(stream.getVideoTracks()[0], stream);

            peerConnection.addTransceiver(stream.getAudioTracks()[0], {
                direction: 'sendrecv',
                streams: [stream]
            })

            peerConnection.addTransceiver(stream.getVideoTracks()[0], {
                direction: 'sendrecv',
                streams: [stream],
                sendEncodings: [
                    // for firefox order matters... first high resolution, then scaled resolutions...
                    {
                        rid: 'high'
                    },
                    {
                        rid: 'mid',
                        scaleResolutionDownBy: 2.0
                    },
                    {
                        rid: 'low',
                        scaleResolutionDownBy: 4.0
                    }
                ]
            })
  
            const offer=await peerConnection.createOffer()
            await peerConnection.setLocalDescription(offer)
            ws.send(JSON.stringify({type:'offer',data:offer.sdp}));

            peerConnection.onicecandidate = function(e) {
                if (e.candidate!=null) {
                    ws.send(JSON.stringify({type:'candidate',data:e.candidate.candidate}));
                }
            };
        }
        </script>
</body>
</html>